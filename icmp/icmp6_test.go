package icmp

import (
	"bytes"
	"fmt"
	"net"
	"testing"

	"github.com/irai/packet"
)

/**
sudo tcpdump -v -XX -t icmp6
icmp6 redirect
*/
var icmp6Redirect = []byte{
	0x02, 0x42, 0xca, 0x78, 0x04, 0x50, 0x7e, 0xe8, 0x94, 0x42, 0x29, 0xaa, 0x86, 0xdd,
	0x60, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x3a, 0xff, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // `.....:.........
	0xce, 0x32, 0xe5, 0xff, 0xfe, 0x0e, 0x67, 0xf4, 0x20, 0x01, 0x44, 0x79, 0x1e, 0x00, 0x82, 0x01, // .2....g...Dy....
	0x00, 0x42, 0xca, 0xff, 0xfe, 0x78, 0x04, 0x50, 0x89, 0x00, 0xbb, 0xf4, 0x00, 0x00, 0x00, 0x00, // .B...x.P........
	0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xe8, 0x94, 0xff, 0xfe, 0x42, 0x29, 0xaa, // ........|....B).
	0x20, 0x01, 0x44, 0x79, 0x1e, 0x00, 0x82, 0x02, 0x00, 0x42, 0x15, 0xff, 0xfe, 0xe6, 0x10, 0x08, // ..Dy.....B......
	0x02, 0x01, 0x7e, 0xe8, 0x94, 0x42, 0x29, 0xaa, 0x04, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ..~..B).........
	0x60, 0x01, 0x90, 0x03, 0x00, 0x40, 0x3a, 0x40, 0x20, 0x01, 0x44, 0x79, 0x1e, 0x00, 0x82, 0x01, // `....@:@..Dy....
	0x00, 0x42, 0xca, 0xff, 0xfe, 0x78, 0x04, 0x50, 0x20, 0x01, 0x44, 0x79, 0x1e, 0x00, 0x82, 0x02, // .B...x.P..Dy....
	0x00, 0x42, 0x15, 0xff, 0xfe, 0xe6, 0x10, 0x08, 0x81, 0x00, 0xb9, 0x7e, 0x01, 0x0a, 0x09, 0x3a, // .B.........~...:
	0x5a, 0x28, 0xab, 0x60, 0xc4, 0x02, 0x0a, 0x00, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, // Z(.`............
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, // ................
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, // .!"#$%&'()*+,-./
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, // 01234567
}

func Test_ICMP6Redirect(t *testing.T) {
	tc := setupTestHandler()
	defer tc.Close()

	ether := packet.Ether(icmp6Redirect)
	fmt.Println("ether", ether)
	ip6Frame := packet.IP6(ether.Payload())
	fmt.Println("ip6", ip6Frame)
	icmp6Frame := ICMP(ip6Frame.Payload())
	fmt.Println("icmp6", icmp6Frame)
	redirect := ICMP6Redirect(icmp6Frame)
	if !redirect.IsValid() {
		t.Fatal("invalid len")
	}
	fmt.Println("redirect", redirect)

	targetIP := net.ParseIP("fe80::7ce8:94ff:fe42:29aa")
	targetMAC, _ := net.ParseMAC("7e:e8:94:42:29:aa")
	dstIP := net.ParseIP("2001:4479:1e00:8202:42:15ff:fee6:1008")
	if !redirect.TargetAddress().Equal(targetIP) ||
		!redirect.DstAddress().Equal(dstIP) ||
		!bytes.Equal(redirect.TargetLinkLayerAddr(), targetMAC) {
		t.Fatal("invalid fields ", redirect)
	}

	_, err := tc.h.ProcessPacket(nil, ether, ip6Frame.Payload())
	if err != nil {
		t.Fatal(err)
	}

}

// sudo tcpdump -en -vv -XX -t icmp6
// 02:42:ca:78:04:50 > 8c:85:90:ae:ab:fc, ethertype IPv6 (0x86dd), length 86: (hlim 255, next-header ICMPv6 (58) payload length: 32)
// fe80::ce32:e5ff:fe0e:67f4 > ff02::1: [icmp6 sum ok] ICMP6, neighbor advertisement, length 32, tgt is fe80::ce32:e5ff:fe0e:67f4, Flags [override]
//   destination link-address option (2), length 8 (1): 02:42:ca:78:04:50
//   0x0000:  0242 ca78 0450
var testicmp6NAOverride = []byte{
	0x8c, 0x85, 0x90, 0xae, 0xab, 0xfc, 0x02, 0x42, 0xca, 0x78, 0x04, 0x50, 0x86, 0xdd, 0x60, 0x00, //  .......B.x.P..`.
	0x00, 0x00, 0x00, 0x20, 0x3a, 0xff, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x32, //  ....:..........2
	0xe5, 0xff, 0xfe, 0x0e, 0x67, 0xf4, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //  ....g...........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x88, 0x00, 0x54, 0x27, 0x20, 0x00, 0x00, 0x00, 0xfe, 0x80, //  ........T'......
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x32, 0xe5, 0xff, 0xfe, 0x0e, 0x67, 0xf4, 0x02, 0x01, //  .......2....g...
	0x02, 0x42, 0xca, 0x78, 0x04, 0x50, //  .B.x.P
}

// f8:d0:27:3c:9f:86 > 02:42:ca:78:04:50, ethertype IPv6 (0x86dd), length 78: (hlim 255, next-header ICMPv6 (58) payload length: 24)
// fe80::fad0:27ff:fe3c:9f86 > fe80::42:caff:fe78:450: [icmp6 sum ok] ICMP6, neighbor advertisement, length 24, tgt is fe80::fad0:27ff:fe3c:9f86, Flags [solicited]
var testicmp6NASolicited = []byte{
	0x02, 0x42, 0xca, 0x78, 0x04, 0x50, 0xf8, 0xd0, 0x27, 0x3c, 0x9f, 0x86, 0x86, 0xdd, 0x60, 0x00, //  .B.x.P..'<....`.
	0x00, 0x00, 0x00, 0x18, 0x3a, 0xff, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa, 0xd0, //  ....:...........
	0x27, 0xff, 0xfe, 0x3c, 0x9f, 0x86, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, //  '..<...........B
	0xca, 0xff, 0xfe, 0x78, 0x04, 0x50, 0x88, 0x00, 0xec, 0xf7, 0x40, 0x00, 0x00, 0x00, 0xfe, 0x80, //  ...x.P....@.....
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa, 0xd0, 0x27, 0xff, 0xfe, 0x3c, 0x9f, 0x86, //  ........'..<..
}

var testicmp6RourterSolicitation = []byte{
	0x02, 0x42, 0xca, 0x78, 0x04, 0x50, 0xf8, 0xd0, 0x27, 0x3c, 0x9f, 0x86, 0x86, 0xdd, 0x60, 0x00, //  .B.x.P..'<....`.
	0x00, 0x00, 0x00, 0x08, 0x3a, 0xff, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa, 0xd0, //  ....:...........
	0x27, 0xff, 0xfe, 0x3c, 0x9f, 0x86, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, //  '..<...........B
	0xca, 0xff, 0xfe, 0x78, 0x04, 0x50,
	0x85, 0x00, 0xb6, 0x46, 0x00, 0x00, 0x00, 0x00, // empty payload
}

func TestHandler_ProcessPacket(t *testing.T) {
	tc := setupTestHandler()
	defer tc.Close()

	mac, _ := net.ParseMAC("02:42:ca:78:04:50")

	tests := []struct {
		name       string
		frame      []byte
		wantResult packet.Result
		wantErr    bool
	}{
		{name: "na_override", frame: testicmp6NAOverride, wantErr: false,
			wantResult: packet.Result{Update: true, SrcAddr: packet.Addr{MAC: mac, IP: net.ParseIP("fe80::ce32:e5ff:fe0e:67f4")}}},
		{name: "na_solicited", frame: testicmp6NASolicited, wantErr: false,
			wantResult: packet.Result{Update: false, SrcAddr: packet.Addr{}}},
		{name: "rs_nopayload", frame: testicmp6RourterSolicitation, wantErr: false,
			wantResult: packet.Result{Update: false, SrcAddr: packet.Addr{}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ether := packet.Ether(tt.frame)
			ip6Frame := packet.IP6(ether.Payload())
			if err := ip6Frame.IsValid(); err != nil {
				t.Fatal("invalid ip6 frame", err)
			}

			gotResult, err := tc.h.ProcessPacket(nil, ether, ip6Frame.Payload())
			if (err != nil) != tt.wantErr {
				t.Errorf("Handler.ProcessPacket() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if gotResult.Update != tt.wantResult.Update {
				t.Errorf("Handler.ProcessPacket() invalid result update=%v, want=%v", gotResult.Update, tt.wantResult.Update)
			}
			if !gotResult.SrcAddr.IP.Equal(tt.wantResult.SrcAddr.IP) ||
				!bytes.Equal(gotResult.SrcAddr.MAC, tt.wantResult.SrcAddr.MAC) {
				t.Errorf("Handler.ProcessPacket() invalid addr=%v, want=%v", gotResult.SrcAddr, tt.wantResult.SrcAddr)
				return
			}
		})
	}
}
